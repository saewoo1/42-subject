# cub3d
---

이 과제는 miniLibX를 사용하여 3d 게임을 만드는 것이 목표입니다.

## 사용 언어
C

## 학습내용
- 라이브러리 설치
- 키 hook
- images 사용해서 이미지 적용
- 파일 가져와서 맵 만들기
- 게임처럼 동작 하도록 만들기
- 에러 핸들링
- 누수 관리
- 레이캐스팅
- 2D 화면을 3D처럼 보이게 하는 방법

### 과제 요구 사항

- 벽이 어느 쪽 (동, 서, 남, 북) 을 향하고 있는지에 따라 서로 다른 벽 텍스쳐 (텍스쳐는 직접 골라 사용하세요) 를 사용하여야 합니다.
- 여러분의 프로그램은 벽 대신 아이템 (스프라이트) 을 표시할 수 있어야 합니다.
- 여러분의 프로그램은 바닥과 천장의 색을 서로 다르게 설정할 수 있어야 합니다.
- 언젠가 Deepthought가 여러분의 프로젝트를 평가하게 될 날을 대비하여, 여러분의 프로그램은 두 번째 인자가 "--save" 일 때 첫 번째로 렌더링된 이미지를 bmp 형식으로 저장해야 합니다.

- 두 번째 인자가 없을 경우, 프로그램은 다음 규칙을 준수하면서 화면 창에 영상을 표시합니다.
  - 키보드의 왼쪽과 오른쪽 화살표 키는 카메라의 시점을 회전시킬 수 있어야 합니다. (왼쪽 및 오른쪽 보기)
  - W, A, S, D 키는 맵 내부에서 카메라를 이동시킬 수 있어야 합니다. (캐릭터의 이동)
  - ESC를 누르면 창이 닫히고 프로그램이 정상적으로 종료되어야 합니다.
  - 창 상단 표시줄에 있는 빨간색 십자가를 클릭하면 창이 닫히고 프로그램이 정상적으로 종료되어야 합니다.
  - 지도에 표시된 화면 크기가 디스플레이 해상도보다 크면, 현재 디스플레이의 해상도에 따라 윈도우 크기가 설정될 것입니다.
  - minilibX의 이미지를 사용하는 것을 적극 권장합니다.

- 여러분의 프로그램은 먼저 .cub 확장자를 가진 지도 파일을 첫 번째 인자로 받아와야 합니다.
  - 지도는 4개의 문자로만 구성되어야 합니다. (빈 공간인 경우 0, 벽인 경우 1, 아이템은 2, 플레이어의 시작 위치와 그에 따른 시점은 N, S, E, W)
  지도는 벽으로 둘러쌓여 있어야 합니다. 그렇지 않다면 프로그램은 오류를 반환해야 합니다.
  - 지도 내용을 제외하고는, 각각의 요소들은 하나 혹은 그 이상의 빈 줄로 분리될 수 있습니다.
  - 지도 내용이 항상 맨 마지막에 있어야 한다는 점을 제외하면, 다른 요소들은 어떤 순서로든 파일 내부에 저장되어 있을 수 있습니다.
  - 지도를 제외하고, 요소에서 각 유형의 정보는 하나 이상의 공백으로 구분될 수 있습니다.
  - 지도는 파일 내에서 보이는 것처럼 불러 올 수 있어야 합니다. 공백은 지도의 유효한 부분이며, 처리는 여러분의 몫입니다. 여러분은 규칙대로 만들어진 모든 종류의 지도를 제대로 불러올 수 있어야 합니다.

- 각 요소 (지도 제외) 의 첫 번째 정보는 (하나 또는 두개의 문자로 구성된) 유형 식별자이며, 각 객체에 대한 모든 구체적인 정보는 다음과 같은 엄격한 규칙을 따릅니다
  - 북쪽 벽 텍스쳐 : 북쪽 벽 텍스쳐가 담겨있는 경로
    - NO ./path_to_the_north_texture

  - 남쪽 벽 텍스쳐 : 남쪽 벽 텍스쳐가 담겨있는 경로
    - SO ./path_to_the_south_texture

  - 서쪽 벽 텍스쳐 : 서쪽 벽 텍스쳐가 담겨있는 경로
    - WE ./path_to_the_west_texture

  - 동쪽 벽 텍스쳐 : 동쪽 벽 텍스쳐가 담겨있는 경로
    - EA ./path_to_the_east_texture

  - 바닥 색상 : [0, 255] 사이의 RGB 색상 : 0, 255, 255
    - F 220,100,0

  - 천장 색상 : [0, 255] 사이의 RGB 색상 : 0, 255, 255
    - C 225,30,0

- 맵 파일에서 잘못된 구성이 발견되었을 경우, 프로그램을 올바르게 종료하고 "Error\n" 을 반환한 후, 여러분이 정한 명시적 오류 메시지가 표시되어야 합니다.

- 예시
```text
NO ./path_to_the_north_texture
SO ./path_to_the_south_texture
WE ./path_to_the_west_texture
EA ./path_to_the_east_texture

F 220,100,0
C 225,30,0

		1111111111111111111111111
		1000000000110000000000001 111 111
		1011000001110000002000001 101
		10010000000000000000000011111
11111111101100000111000000000001
100000000011000001110111111111111
11110111111111011100000010001
11110111111111011101010010001
11000000110101011100000010001
10002000000000001100000010001
10000000000000001101010010001
11000001110101011111011110N0111
11110111 1110101 101111010001
11111111 1111111 111111111111
```

### mlx 관련

```C

void * mlx_init(void);
// - 나의 소프트웨어와 OS의 디스플레이를 연결해주는 함수.

void * mlx_new_window ( void mlx_ptr, int size_x, int size_y, char *title );
// - 디스플레이에 새로운 윈도우를 띄우는 함수. 앞서 받아온 포인터와 가로 세로 크기, 그리고 창의 제목을 받아서 띄운다.

int mlx_loop ( void *mlx_ptr );
// - 띄운 창에서 키보드와 마우스의 입력을 기다린다. 혹은 창의 일부를 다시 그리는 역할도 함

int	mlx_key_hook(void *win_ptr, int (*funct_ptr)(), void *param);
int mlx_mouse_hook(void *win_ptr, int (*funct_ptr)(), void *param);
int mlx_expose_hook(void *win_ptr, int (*funct_ptr)(), void *param);
// - 위 세가지 함수는 모두 같은 방식으로 작동한다.
// - funct_ptr는 이벤트 발생시 당신이 호출하고 싶은 함수를 가리키는 함수 포인터 이다.
// - param의 주소는 호출될 때마다 전달되고 필요한 매개 변수를 저장하는 데 사용해야한다.

void	*mlx_new_image(void *mlx_ptr, int width, int height);
// - 새 이미지를 메모리에 생성시킨다.

int mlx_put_image_to_window(void *mlx_ptr, void *win_ptr, void *img_ptr, int x, int y);
// - 이미지 내부를 그릴 수 있으며 언제든지 지정된 창 내에서 이미지를 덤프하여 화면에 표시 할 수 있다.

char	*mlx_get_data_addr(void *img_ptr, int *bits_per_pixel, int *size_line, int *endian);
// - mlx_get_data_addr ()는 생성된 이미지에 대한 정보를 리턴해서 사용자가 나중에 이미지를 수정할 수 있도록 한다.

int mlx_destroy_image(void *mlx_ptr, void *img_ptr);
// - 주어진 이미지(img_ptr)을 삭제한다.

```
